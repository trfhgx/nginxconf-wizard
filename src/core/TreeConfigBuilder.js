import Handlebars from 'handlebars';

/**
 * TreeConfigBuilder - Builds nginx configurations from tree-based state
 * Generates flexible configs by composing server blocks, locations, and upstreams
 */
class TreeConfigBuilder {
  constructor() {
    this.state = {
      servers: [],
      upstreams: [],
      globalSettings: {}
    };
    this.errors = [];
    this.warnings = [];
    this.registerHelpers();
  }

  /**
   * Register Handlebars helpers
   */
  registerHelpers() {
    // Conditional equality
    Handlebars.registerHelper('eq', (a, b) => a === b);
    Handlebars.registerHelper('neq', (a, b) => a !== b);
    
    // Logical operators
    Handlebars.registerHelper('or', (...args) => {
      args.pop();
      return args.some(arg => !!arg);
    });
    
    Handlebars.registerHelper('and', (...args) => {
      args.pop();
      return args.every(arg => !!arg);
    });

    // SSL helpers
    Handlebars.registerHelper('sslProtocols', () => 'TLSv1.2 TLSv1.3');
    Handlebars.registerHelper('sslCiphers', () => 
      'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384'
    );
  }

  /**
   * Set global settings
   */
  setGlobalSettings(settings) {
    this.state.globalSettings = { ...settings };
    return this;
  }

  /**
   * Set full state from TreeWizard
   */
  setState(state) {
    this.state = { ...state };
    return this;
  }

  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }

  /**
   * Validate configuration
   */
  validate() {
    this.errors = [];
    this.warnings = [];

    // Must have at least one server
    if (this.state.servers.length === 0) {
      this.errors.push('At least one server block is required');
    }

    // Validate each server
    for (const server of this.state.servers) {
      // Domain required
      if (!server.domain?.primary) {
        this.errors.push(`Server ${server.name}: Primary domain is required`);
      }

      // SSL validation
      if (server.ssl?.enabled && server.ssl?.provider === 'custom') {
        if (!server.ssl.certPath || !server.ssl.keyPath) {
          this.errors.push(`Server ${server.domain?.primary}: Custom SSL requires certPath and keyPath`);
        }
      }

      // HTTP/3 requires HTTP/2
      if (server.ssl?.http3 && !server.ssl?.http2) {
        this.warnings.push(`Server ${server.domain?.primary}: HTTP/3 requires HTTP/2 - enabling HTTP/2`);
        server.ssl.http2 = true;
      }

      // Check for location conflicts
      const paths = server.locations?.map(l => l.path) || [];
      const duplicates = paths.filter((path, idx) => paths.indexOf(path) !== idx);
      if (duplicates.length > 0) {
        this.warnings.push(`Server ${server.domain?.primary}: Duplicate location paths: ${duplicates.join(', ')}`);
      }

      // Validate upstream references
      for (const location of server.locations || []) {
        if (location.upstream) {
          const upstreamExists = 
            server.upstreams?.some(u => u.name === location.upstream) ||
            this.state.upstreams?.some(u => u.name === location.upstream);
          
          if (!upstreamExists) {
            this.errors.push(`Server ${server.domain?.primary}: Location ${location.path} references undefined upstream '${location.upstream}'`);
          }
        }
      }
    }

    // Validate global upstreams
    for (const upstream of this.state.upstreams || []) {
      if (!upstream.servers || upstream.servers.length === 0) {
        this.errors.push(`Upstream ${upstream.name}: At least one server is required`);
      }
    }

    return {
      valid: this.errors.length === 0,
      errors: this.errors,
      warnings: this.warnings
    };
  }

  /**
   * Build nginx configuration
   */
  async build() {
    const validation = this.validate();
    if (!validation.valid) {
      throw new Error(`Configuration validation failed:\n${validation.errors.join('\n')}`);
    }

    const config = this.generateConfig();
    return config;
  }

  /**
   * Generate the nginx configuration string
   */
  generateConfig() {
    const lines = [];
    const { globalSettings, servers, upstreams } = this.state;

    // Header
    lines.push('# Nginx Configuration');
    lines.push('# Generated by nginxconf-wizard (Tree Mode)');
    lines.push(`# Generated at: ${new Date().toISOString()}`);
    lines.push('');

    // Worker processes
    lines.push(`worker_processes ${globalSettings.workerProcesses || 'auto'};`);
    lines.push('');
    lines.push('events {');
    lines.push(`    worker_connections ${globalSettings.workerConnections || 1024};`);
    lines.push('}');
    lines.push('');

    // HTTP block
    lines.push('http {');
    lines.push('    include /etc/nginx/mime.types;');
    lines.push('    default_type application/octet-stream;');
    lines.push('');
    lines.push('    # Logging');
    lines.push('    log_format main \'$remote_addr - $remote_user [$time_local] "$request" \'');
    lines.push('                    \'$status $body_bytes_sent "$http_referer" \'');
    lines.push('                    \'"$http_user_agent" "$http_x_forwarded_for"\';');
    lines.push('');
    lines.push('    access_log /var/log/nginx/access.log main;');
    lines.push('    error_log /var/log/nginx/error.log warn;');
    lines.push('');
    lines.push('    # Performance');
    lines.push('    sendfile on;');
    lines.push('    tcp_nopush on;');
    lines.push('    tcp_nodelay on;');
    lines.push('    keepalive_timeout 65;');
    lines.push('    types_hash_max_size 2048;');
    lines.push('');

    // Compression
    if (globalSettings.compression) {
      lines.push('    # Gzip compression');
      lines.push('    gzip on;');
      lines.push('    gzip_vary on;');
      lines.push('    gzip_proxied any;');
      lines.push('    gzip_comp_level 6;');
      lines.push('    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss application/atom+xml image/svg+xml;');
      lines.push('');
    }

    // Collect all rate limit zones needed
    const rateLimitZones = this.collectRateLimitZones();
    if (rateLimitZones.length > 0) {
      lines.push('    # Rate limit zones');
      for (const zone of rateLimitZones) {
        lines.push(`    limit_req_zone $binary_remote_addr zone=${zone.name}:10m rate=${zone.rate};`);
      }
      lines.push('');
    }

    // Collect all cache zones needed
    const cacheZones = this.collectCacheZones();
    if (cacheZones.length > 0) {
      lines.push('    # Proxy cache zones');
      for (const zone of cacheZones) {
        lines.push(`    proxy_cache_path /var/cache/nginx/${zone.name} levels=1:2 keys_zone=${zone.name}:10m max_size=100m inactive=60m use_temp_path=off;`);
      }
      lines.push('');
    }

    // Global upstreams
    for (const upstream of upstreams || []) {
      lines.push(...this.generateUpstream(upstream, 1));
    }

    // Server blocks
    for (const server of servers) {
      // Server-specific upstreams
      for (const upstream of server.upstreams || []) {
        lines.push(...this.generateUpstream(upstream, 1));
      }

      // Generate server block(s)
      lines.push(...this.generateServerBlock(server, globalSettings));
    }

    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Collect rate limit zones from all locations
   */
  collectRateLimitZones() {
    const zones = [];
    for (const server of this.state.servers) {
      for (const location of server.locations || []) {
        if (location.rateLimit && location.rateLimitValue) {
          const zoneName = `${location.type}_${location.path.replace(/[^a-zA-Z0-9]/g, '_')}_limit`;
          zones.push({ name: zoneName, rate: location.rateLimitValue });
        }
      }
    }
    return zones;
  }

  /**
   * Collect cache zones from all locations
   */
  collectCacheZones() {
    const zones = new Map();
    for (const server of this.state.servers) {
      for (const location of server.locations || []) {
        if (location.cache?.zone) {
          zones.set(location.cache.zone, { name: location.cache.zone });
        }
      }
    }
    return Array.from(zones.values());
  }

  /**
   * Generate upstream block
   */
  generateUpstream(upstream, indentLevel = 0) {
    const indent = '    '.repeat(indentLevel);
    const lines = [];

    lines.push(`${indent}# Upstream: ${upstream.name}`);
    lines.push(`${indent}upstream ${upstream.name} {`);

    // Load balancing method
    if (upstream.loadBalancing && upstream.loadBalancing !== 'round_robin') {
      lines.push(`${indent}    ${upstream.loadBalancing};`);
    }

    // Servers
    for (const server of upstream.servers || []) {
      let serverLine = `${indent}    server ${server.host}:${server.port}`;
      if (upstream.maxFails) serverLine += ` max_fails=${upstream.maxFails}`;
      if (upstream.failTimeout) serverLine += ` fail_timeout=${upstream.failTimeout}s`;
      if (server.weight) serverLine += ` weight=${server.weight}`;
      if (server.backup) serverLine += ' backup';
      serverLine += ';';
      lines.push(serverLine);
    }

    // Keepalive
    if (upstream.keepalive) {
      lines.push('');
      lines.push(`${indent}    keepalive ${upstream.keepalive};`);
      lines.push(`${indent}    keepalive_timeout 60s;`);
    }

    lines.push(`${indent}}`);
    lines.push('');

    return lines;
  }

  /**
   * Generate server block
   */
  generateServerBlock(server, globalSettings) {
    const lines = [];
    const domain = server.domain;
    const ssl = server.ssl;

    // HTTP to HTTPS redirect (if SSL enabled)
    if (ssl?.enabled) {
      lines.push('    # HTTP -> HTTPS Redirect');
      lines.push('    server {');
      lines.push(`        listen ${domain.port || 80};`);
      lines.push(`        listen [::]:${domain.port || 80};`);
      lines.push(`        server_name ${domain.primary}${domain.aliases?.length ? ' ' + domain.aliases.join(' ') : ''};`);
      lines.push('        return 301 https://$server_name$request_uri;');
      lines.push('    }');
      lines.push('');
    }

    // Main server block
    lines.push(`    # Server: ${domain.primary}`);
    lines.push('    server {');

    // Listen directive
    if (ssl?.enabled) {
      let listenDirective = `        listen ${domain.httpsPort || 443} ssl`;
      if (ssl.http3) listenDirective += ' http3';
      lines.push(`${listenDirective};`);
      lines.push(`        listen [::]:${domain.httpsPort || 443} ssl${ssl.http3 ? ' http3' : ''};`);
      
      if (ssl.http2) {
        lines.push('        http2 on;');
      }
    } else {
      lines.push(`        listen ${domain.port || 80};`);
      lines.push(`        listen [::]:${domain.port || 80};`);
    }

    // Server name
    lines.push(`        server_name ${domain.primary}${domain.aliases?.length ? ' ' + domain.aliases.join(' ') : ''};`);
    lines.push('');

    // SSL configuration
    if (ssl?.enabled) {
      lines.push(...this.generateSSLConfig(ssl, domain.primary));
    }

    // Logging
    lines.push('        # Logging');
    lines.push(`        access_log /var/log/nginx/${domain.primary}/access.log main;`);
    lines.push(`        error_log /var/log/nginx/${domain.primary}/error.log warn;`);
    lines.push('');

    // Security headers
    if (globalSettings.securityHeaders) {
      lines.push('        # Security Headers');
      lines.push('        add_header X-Frame-Options "SAMEORIGIN" always;');
      lines.push('        add_header X-Content-Type-Options "nosniff" always;');
      lines.push('        add_header X-XSS-Protection "1; mode=block" always;');
      lines.push('        add_header Referrer-Policy "strict-origin-when-cross-origin" always;');
      if (ssl?.enabled) {
        lines.push('        add_header Strict-Transport-Security "max-age=63072000; includeSubDomains" always;');
      }
      lines.push('');
    }

    // Locations
    for (const location of server.locations || []) {
      lines.push(...this.generateLocation(location));
    }

    // Default deny hidden files
    lines.push('        # Deny access to hidden files');
    lines.push('        location ~ /\\. {');
    lines.push('            deny all;');
    lines.push('            access_log off;');
    lines.push('            log_not_found off;');
    lines.push('        }');

    lines.push('    }');
    lines.push('');

    return lines;
  }

  /**
   * Generate SSL configuration
   */
  generateSSLConfig(ssl, domain) {
    const lines = [];

    lines.push('        # SSL Configuration');
    
    // Certificate paths based on provider
    if (ssl.provider === 'letsencrypt') {
      lines.push(`        ssl_certificate /etc/letsencrypt/live/${domain}/fullchain.pem;`);
      lines.push(`        ssl_certificate_key /etc/letsencrypt/live/${domain}/privkey.pem;`);
      lines.push(`        ssl_trusted_certificate /etc/letsencrypt/live/${domain}/chain.pem;`);
    } else if (ssl.provider === 'cloudflare') {
      lines.push(`        ssl_certificate /etc/nginx/ssl/${domain}/cloudflare.pem;`);
      lines.push(`        ssl_certificate_key /etc/nginx/ssl/${domain}/cloudflare.key;`);
      lines.push('        ssl_client_certificate /etc/nginx/ssl/cloudflare/origin-pull-ca.pem;');
      lines.push('        ssl_verify_client on;');
    } else if (ssl.provider === 'custom') {
      lines.push(`        ssl_certificate ${ssl.certPath};`);
      lines.push(`        ssl_certificate_key ${ssl.keyPath};`);
    } else if (ssl.provider === 'self-signed') {
      lines.push(`        ssl_certificate /etc/nginx/ssl/${domain}/cert.pem;`);
      lines.push(`        ssl_certificate_key /etc/nginx/ssl/${domain}/key.pem;`);
    }

    // SSL settings
    lines.push('');
    lines.push('        ssl_protocols TLSv1.2 TLSv1.3;');
    lines.push('        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;');
    lines.push('        ssl_prefer_server_ciphers off;');
    lines.push('        ssl_session_timeout 1d;');
    lines.push('        ssl_session_cache shared:SSL:10m;');
    lines.push('        ssl_session_tickets off;');

    // OCSP stapling (only for Let's Encrypt)
    if (ssl.provider === 'letsencrypt') {
      lines.push('');
      lines.push('        # OCSP Stapling');
      lines.push('        ssl_stapling on;');
      lines.push('        ssl_stapling_verify on;');
      lines.push('        resolver 8.8.8.8 8.8.4.4 valid=300s;');
      lines.push('        resolver_timeout 5s;');
    }

    // HTTP/3 header
    if (ssl.http3) {
      lines.push('');
      lines.push('        add_header Alt-Svc \'h3=":443"; ma=86400\';');
    }

    lines.push('');

    return lines;
  }

  /**
   * Generate location block
   */
  generateLocation(location) {
    const lines = [];
    const type = location.type;

    lines.push(`        # Location: ${location.path} (${type})`);
    lines.push(`        location ${location.path} {`);

    if (type === 'static') {
      lines.push(...this.generateStaticLocation(location));
    } else if (type === 'spa') {
      lines.push(...this.generateSPALocation(location));
    } else if (type === 'proxy') {
      lines.push(...this.generateProxyLocation(location));
    } else if (type === 'api') {
      lines.push(...this.generateAPILocation(location));
    } else if (type === 'websocket') {
      lines.push(...this.generateWebSocketLocation(location));
    } else if (type === 'redirect') {
      lines.push(...this.generateRedirectLocation(location));
    } else if (type === 'health') {
      lines.push(...this.generateHealthLocation(location));
    } else if (type === 'cache') {
      lines.push(...this.generateCachedProxyLocation(location));
    } else if (type === 'custom') {
      lines.push(...this.generateCustomLocation(location));
    }

    lines.push('        }');
    lines.push('');

    return lines;
  }

  /**
   * Generate static location directives
   */
  generateStaticLocation(location) {
    const lines = [];
    
    lines.push(`            root ${location.root};`);
    if (location.index) {
      lines.push(`            index ${location.index};`);
    }
    if (location.autoindex) {
      lines.push('            autoindex on;');
    }
    if (location.caching) {
      lines.push('');
      lines.push(`            expires ${location.cacheExpires || '1y'};`);
      lines.push('            add_header Cache-Control "public, immutable";');
      lines.push('            access_log off;');
    }

    return lines;
  }

  /**
   * Generate SPA location directives
   */
  generateSPALocation(location) {
    const lines = [];
    
    lines.push(`            root ${location.root};`);
    lines.push(`            try_files $uri $uri/ ${location.fallback || '/index.html'};`);
    
    if (location.caching) {
      lines.push('');
      lines.push('            # Cache static assets');
      lines.push('            location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {');
      lines.push('                expires 1y;');
      lines.push('                add_header Cache-Control "public, immutable";');
      lines.push('                access_log off;');
      lines.push('            }');
    }

    return lines;
  }

  /**
   * Generate proxy location directives
   */
  generateProxyLocation(location) {
    const lines = [];
    const target = location.upstream ? `http://${location.upstream}` : location.target;

    lines.push(`            proxy_pass ${target};`);
    lines.push('            proxy_http_version 1.1;');
    lines.push('');
    lines.push('            proxy_set_header Host $host;');
    lines.push('            proxy_set_header X-Real-IP $remote_addr;');
    lines.push('            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;');
    lines.push('            proxy_set_header X-Forwarded-Proto $scheme;');

    if (location.websocket) {
      lines.push('            proxy_set_header Upgrade $http_upgrade;');
      lines.push('            proxy_set_header Connection "upgrade";');
    }

    if (location.timeout) {
      lines.push('');
      lines.push(`            proxy_connect_timeout ${location.timeout}s;`);
      lines.push(`            proxy_send_timeout ${location.timeout}s;`);
      lines.push(`            proxy_read_timeout ${location.timeout}s;`);
    }

    return lines;
  }

  /**
   * Generate API location directives
   */
  generateAPILocation(location) {
    const lines = [];
    const target = location.upstream ? `http://${location.upstream}` : location.target;

    // CORS
    if (location.cors) {
      lines.push(`            add_header Access-Control-Allow-Origin ${location.corsOrigin || '*'} always;`);
      lines.push('            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, PATCH, OPTIONS" always;');
      lines.push('            add_header Access-Control-Allow-Headers "Authorization, Content-Type, X-Requested-With" always;');
      lines.push('            add_header Access-Control-Max-Age 86400 always;');
      lines.push('');
      lines.push('            if ($request_method = OPTIONS) {');
      lines.push('                return 204;');
      lines.push('            }');
      lines.push('');
    }

    // Rate limiting
    if (location.rateLimit) {
      const zoneName = `${location.type}_${location.path.replace(/[^a-zA-Z0-9]/g, '_')}_limit`;
      lines.push(`            limit_req zone=${zoneName} burst=${location.rateLimitBurst || 20} nodelay;`);
      lines.push('');
    }

    // Proxy
    lines.push(`            proxy_pass ${target};`);
    lines.push('            proxy_http_version 1.1;');
    lines.push('');
    lines.push('            proxy_set_header Host $host;');
    lines.push('            proxy_set_header X-Real-IP $remote_addr;');
    lines.push('            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;');
    lines.push('            proxy_set_header X-Forwarded-Proto $scheme;');

    return lines;
  }

  /**
   * Generate WebSocket location directives
   */
  generateWebSocketLocation(location) {
    const lines = [];
    const target = location.upstream ? `http://${location.upstream}` : location.target;

    lines.push(`            proxy_pass ${target};`);
    lines.push('            proxy_http_version 1.1;');
    lines.push('');
    lines.push('            # WebSocket support');
    lines.push('            proxy_set_header Upgrade $http_upgrade;');
    lines.push('            proxy_set_header Connection "upgrade";');
    lines.push('');
    lines.push('            proxy_set_header Host $host;');
    lines.push('            proxy_set_header X-Real-IP $remote_addr;');
    lines.push('            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;');
    lines.push('            proxy_set_header X-Forwarded-Proto $scheme;');

    if (location.timeout && location.timeout > 0) {
      lines.push('');
      lines.push(`            proxy_read_timeout ${location.timeout}s;`);
      lines.push(`            proxy_send_timeout ${location.timeout}s;`);
    }

    return lines;
  }

  /**
   * Generate redirect location directives
   */
  generateRedirectLocation(location) {
    const lines = [];
    lines.push(`            return ${location.code || 301} ${location.destination};`);
    return lines;
  }

  /**
   * Generate health check location directives
   */
  generateHealthLocation(location) {
    const lines = [];
    
    if (location.noLog) {
      lines.push('            access_log off;');
    }
    lines.push(`            return 200 "${location.response || 'OK'}\\n";`);
    lines.push('            add_header Content-Type text/plain;');

    return lines;
  }

  /**
   * Generate cached proxy location directives
   */
  generateCachedProxyLocation(location) {
    const lines = [];
    const target = location.upstream ? `http://${location.upstream}` : location.target;
    const zoneName = location.cache?.zone || 'proxy_cache';

    lines.push(`            proxy_pass ${target};`);
    lines.push('            proxy_http_version 1.1;');
    lines.push('');
    lines.push('            proxy_set_header Host $host;');
    lines.push('            proxy_set_header X-Real-IP $remote_addr;');
    lines.push('            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;');
    lines.push('            proxy_set_header X-Forwarded-Proto $scheme;');
    lines.push('');
    lines.push('            # Caching');
    lines.push(`            proxy_cache ${zoneName};`);
    lines.push(`            proxy_cache_valid 200 ${location.cache?.duration || '10m'};`);
    lines.push('            proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;');
    lines.push('            proxy_cache_lock on;');
    lines.push('            add_header X-Cache-Status $upstream_cache_status;');

    if (location.cache?.bypassCookie) {
      lines.push('');
      lines.push('            # Bypass cache for authenticated users');
      lines.push('            proxy_cache_bypass $cookie_session $cookie_token;');
      lines.push('            proxy_no_cache $cookie_session $cookie_token;');
    }

    return lines;
  }

  /**
   * Generate custom location directives
   */
  generateCustomLocation(location) {
    const lines = [];
    if (location.custom) {
      const customLines = location.custom.split('\n').map(l => `            ${l.trim()}`);
      lines.push(...customLines);
    }
    return lines;
  }

  /**
   * Export state for saving
   */
  exportState() {
    return {
      version: '2.0.0',
      schemaVersion: '2.0.0',
      mode: 'tree',
      generatedAt: new Date().toISOString(),
      ...this.state
    };
  }

  /**
   * Import state from file
   */
  importState(state) {
    this.state = {
      servers: state.servers || [],
      upstreams: state.upstreams || [],
      globalSettings: state.globalSettings || {}
    };
    return this;
  }
}

export default TreeConfigBuilder;
